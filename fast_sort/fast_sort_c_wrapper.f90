! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


MODULE C_SWAP
USE ISO_FORTRAN_ENV , ONLY : REAL64 , INT64
  IMPLICIT NONE


CONTAINS


  
  SUBROUTINE C_SWAP_I64(V1, V2) BIND(C)
    USE SWAP, ONLY: SWAP_I64
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(INOUT) :: V1
    INTEGER(KIND=INT64), INTENT(INOUT) :: V2
  
    CALL SWAP_I64(V1, V2)
  END SUBROUTINE C_SWAP_I64
  

  
  SUBROUTINE C_SWAP_R64(V1, V2) BIND(C)
    USE SWAP, ONLY: SWAP_R64
    IMPLICIT NONE
    REAL(KIND=REAL64), INTENT(INOUT) :: V1
    REAL(KIND=REAL64), INTENT(INOUT) :: V2
  
    CALL SWAP_R64(V1, V2)
  END SUBROUTINE C_SWAP_R64
  
END MODULE C_SWAP


MODULE C_FAST_SELECT
USE ISO_FORTRAN_ENV , ONLY : REAL64 , INT64
USE SWAP , ONLY : SWAP_I64 , SWAP_R64
  IMPLICIT NONE


CONTAINS


  
  SUBROUTINE C_ARGSELECT_R64(VALUES_DIM_1, VALUES, INDICES_DIM_1, INDICES, K, DIVISOR_PRESENT, DIVISOR, MAX_SIZE_PRESENT, MAX_SIZE)&
& BIND(C)
    USE FAST_SELECT, ONLY: ARGSELECT_R64
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: VALUES_DIM_1
    REAL(KIND=REAL64), INTENT(INOUT), DIMENSION(VALUES_DIM_1) :: VALUES
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER(KIND=INT64), INTENT(IN) :: K
    LOGICAL, INTENT(IN) :: DIVISOR_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: DIVISOR
    LOGICAL, INTENT(IN) :: MAX_SIZE_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: MAX_SIZE
  
    IF (DIVISOR_PRESENT) THEN
      IF (MAX_SIZE_PRESENT) THEN
        CALL ARGSELECT_R64(VALUES=VALUES, INDICES=INDICES, K=K, DIVISOR=DIVISOR, MAX_SIZE=MAX_SIZE)
      ELSE
        CALL ARGSELECT_R64(VALUES=VALUES, INDICES=INDICES, K=K, DIVISOR=DIVISOR)
      END IF
    ELSE
      IF (MAX_SIZE_PRESENT) THEN
        CALL ARGSELECT_R64(VALUES=VALUES, INDICES=INDICES, K=K, MAX_SIZE=MAX_SIZE)
      ELSE
        CALL ARGSELECT_R64(VALUES=VALUES, INDICES=INDICES, K=K)
      END IF
    END IF
  END SUBROUTINE C_ARGSELECT_R64
  

  
  SUBROUTINE C_ARGSELECT_I64(VALUES_DIM_1, VALUES, INDICES_DIM_1, INDICES, K, DIVISOR_PRESENT, DIVISOR, MAX_SIZE_PRESENT, MAX_SIZE)&
& BIND(C)
    USE FAST_SELECT, ONLY: ARGSELECT_I64
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: VALUES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(VALUES_DIM_1) :: VALUES
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER(KIND=INT64), INTENT(IN) :: K
    LOGICAL, INTENT(IN) :: DIVISOR_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: DIVISOR
    LOGICAL, INTENT(IN) :: MAX_SIZE_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: MAX_SIZE
  
    IF (DIVISOR_PRESENT) THEN
      IF (MAX_SIZE_PRESENT) THEN
        CALL ARGSELECT_I64(VALUES=VALUES, INDICES=INDICES, K=K, DIVISOR=DIVISOR, MAX_SIZE=MAX_SIZE)
      ELSE
        CALL ARGSELECT_I64(VALUES=VALUES, INDICES=INDICES, K=K, DIVISOR=DIVISOR)
      END IF
    ELSE
      IF (MAX_SIZE_PRESENT) THEN
        CALL ARGSELECT_I64(VALUES=VALUES, INDICES=INDICES, K=K, MAX_SIZE=MAX_SIZE)
      ELSE
        CALL ARGSELECT_I64(VALUES=VALUES, INDICES=INDICES, K=K)
      END IF
    END IF
  END SUBROUTINE C_ARGSELECT_I64
  
END MODULE C_FAST_SELECT


MODULE C_FAST_SORT
USE ISO_FORTRAN_ENV , ONLY : REAL64 , INT64
USE SWAP , ONLY : SWAP_I64 , SWAP_R64
  IMPLICIT NONE


CONTAINS


  
  SUBROUTINE C_ARGSORT_R64(VALUES_DIM_1, VALUES, INDICES_DIM_1, INDICES, MIN_SIZE_PRESENT, MIN_SIZE) BIND(C)
    USE FAST_SORT, ONLY: ARGSORT_R64
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: VALUES_DIM_1
    REAL(KIND=REAL64), INTENT(INOUT), DIMENSION(VALUES_DIM_1) :: VALUES
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(INDICES_DIM_1) :: INDICES
    LOGICAL, INTENT(IN) :: MIN_SIZE_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: MIN_SIZE
  
    IF (MIN_SIZE_PRESENT) THEN
      CALL ARGSORT_R64(VALUES=VALUES, INDICES=INDICES, MIN_SIZE=MIN_SIZE)
    ELSE
      CALL ARGSORT_R64(VALUES=VALUES, INDICES=INDICES)
    END IF
  END SUBROUTINE C_ARGSORT_R64
  

  
  SUBROUTINE C_INSERTION_ARGSORT_R64(VALUES_DIM_1, VALUES, INDICES_DIM_1, INDICES) BIND(C)
    USE FAST_SORT, ONLY: INSERTION_ARGSORT_R64
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: VALUES_DIM_1
    REAL(KIND=REAL64), INTENT(INOUT), DIMENSION(VALUES_DIM_1) :: VALUES
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(INDICES_DIM_1) :: INDICES
  
    CALL INSERTION_ARGSORT_R64(VALUES, INDICES)
  END SUBROUTINE C_INSERTION_ARGSORT_R64
  

  
  SUBROUTINE C_ARGPARTITION_R64(VALUES_DIM_1, VALUES, INDICES_DIM_1, INDICES, LEFT) BIND(C)
    USE FAST_SORT, ONLY: ARGPARTITION_R64
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: VALUES_DIM_1
    REAL(KIND=REAL64), INTENT(INOUT), DIMENSION(VALUES_DIM_1) :: VALUES
    INTEGER, INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER(KIND=INT64) :: LEFT
  
    LEFT = ARGPARTITION_R64(VALUES, INDICES)
  END SUBROUTINE C_ARGPARTITION_R64
  
END MODULE C_FAST_SORT

